#!/usr/bin/env python
#
# Generate a full experiment configuration for PTM UIST 14 experiments.
# This script is dependent upon the document format generated by 
#
# TODO: Currently does not randomize the order of documents since document
# context is one of the "features" of the new UI.
#
# Author: Spence Green
#
import sys
import codecs
from argparse import ArgumentParser
import os
import glob
import math
from os.path import join,basename
import json
import string
import random
import itertools
from collections import defaultdict,Counter

# UI conditions for UIST14 experiments
UI_CONDITIONS = ['pe','imt']
OUT_FILENAME = 'experiment.json'
URL_PREFIX = '/static/data/fren'
TRAIN_DOMAIN_NAME = 'train'

def pw_generator(size=8, chars=string.ascii_uppercase + string.digits + string.ascii_lowercase):
    """
    Simple password generator.

    See:
    http://stackoverflow.com/questions/2257441/python-random-string-generation-with-upper-case-letters-and-digits
    """
    return ''.join(random.choice(chars) for x in xrange(size))

def load_source_dict(source_paths):
    """
    """
    source_to_paths = {}
    url_list = []
    for path in source_paths:
        domain_name = basename(path)
        file_list = [join(URL_PREFIX,domain_name,basename(x)) for x in glob.glob(path + '/*.json')]
        file_list.sort()
        url_list.extend(file_list)
        source_to_paths[domain_name] = file_list
    assert TRAIN_DOMAIN_NAME in source_to_paths
    return source_to_paths,url_list

def make_layout(num_users, num_conditions, source_dict):
    """
    Make the experimental design, randomizing documents per condition
    and the order of genres.
    """
    print 'Generating randomized layout...'
    # First, assign documents to conditions
    document_condition_cnt = Counter()
    user_to_condition = defaultdict(dict)
    domains = source_dict.keys()
    domains.remove(TRAIN_DOMAIN_NAME)
    for i in xrange(num_users):
        assignments_per_condition = (i / num_conditions) + 1
        for j in xrange(num_conditions):
            condition = UI_CONDITIONS[j]
            random.shuffle(domains)
            for domain in domains:
                url_list = source_dict[domain]
                max_docs = len(url_list) / 2
                if len(url_list) % 2 != 0:
                    max_docs += (i+j) % 2
                random.shuffle(url_list)
                sample_urls = []
                for url in url_list:
                    k = '%s:%s' % (condition,url)
                    if document_condition_cnt[k] < assignments_per_condition:
                        sample_urls.append(url)
                        document_condition_cnt[k] += 1
                    if len(sample_urls) == max_docs:
                        break
                sample_urls.sort()
                print 'User: %d Condition %s domain: %s #docs %d' % (i,UI_CONDITIONS[j], domain, len(sample_urls))
                if condition in user_to_condition[i]:
                    user_to_condition[i][condition].extend(sample_urls)
                else:
                    user_to_condition[i][condition] = sample_urls
    return user_to_condition

def make_experiment(user_prefix, num_users, src_lang,
                    tgt_lang, source_paths):
    """
    """

    source_dict,url_list = load_source_dict(source_paths)

    num_conditions = len(UI_CONDITIONS)
    assert num_conditions == 2
    
    user_to_condition = make_layout(num_users, num_conditions, source_dict)

    spec = defaultdict(dict)
    document_count = Counter()
    print
    print 'Users:'
    for i in xrange(num_users):
        # Flip the condition for this subject
        UI_CONDITIONS.reverse()
        
        username = user_prefix + str(i)
        password = pw_generator()
        spec[username]['password'] = password
        spec[username]['src_lang'] = src_lang
        spec[username]['tgt_lang'] = tgt_lang
        sessions = []
        docs_per_condition = Counter()
        for condition in UI_CONDITIONS:
            for url in user_to_condition[i][condition]:
                k = '%s:%s' % (url,condition)
                document_count[k] += 1
                sessions.append((url,condition))
                docs_per_condition[condition] += 1
        spec[username]['sessions'] = sessions

        # Sanity checking
        print username,password,str(UI_CONDITIONS)
        print ' #docs pe: %d imt: %d' % (docs_per_condition['pe'], docs_per_condition['imt'])
        
        # Training documents alternate between post-editing
        ui_id = 0
        training = []
        for url in source_dict[TRAIN_DOMAIN_NAME]:
            training.append((url,UI_CONDITIONS[ui_id]))
            ui_id = 1 if ui_id == 0 else 0
        spec[username]['training'] = training

    # Sanity checking
    print
    print 'Document assignments per condition:'
    for url in url_list:
        for condition in UI_CONDITIONS:
            k = '%s:%s' % (url,condition)
            print '%s\t%d' % (k,document_count[k])
    
    # Serialize to json
    with open(OUT_FILENAME,'w') as out_file:
        out_file.write(json.dumps(spec))
    print 'Wrote spec to: ',OUT_FILENAME
    

def main():
    """
    Process command line arguments and generate.
    """
    desc='Make a full experiment configuration'
    parser=ArgumentParser(description=desc)
    parser.add_argument('user_prefix',
                        help='All usernames will have this prefix.')
    parser.add_argument('num_users',
                        type=int,
                        help='Number of user profiles to generate.')
    parser.add_argument('src_lang',
                        help='Source language.')
    parser.add_argument('tgt_lang',
                        help='Target language.')
    parser.add_argument('source_paths',
                        metavar='source_path',
                        nargs='+',
                        help='Path to data source with json files.')
    args = parser.parse_args()

    make_experiment(args.user_prefix,
                    args.num_users,
                    args.src_lang,
                    args.tgt_lang,
                    args.source_paths)
    
if __name__ == '__main__':
    main()



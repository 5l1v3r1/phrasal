package edu.stanford.nlp.mt.tools;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import edu.stanford.nlp.mt.Phrasal;
import edu.stanford.nlp.mt.base.IOTools;
import edu.stanford.nlp.mt.base.IString;
import edu.stanford.nlp.mt.base.IStrings;
import edu.stanford.nlp.mt.base.RichTranslation;
import edu.stanford.nlp.mt.base.Sequence;
import edu.stanford.nlp.mt.metrics.BLEUMetric;
import edu.stanford.nlp.stats.Counter;
import edu.stanford.nlp.util.Pair;
import edu.stanford.nlp.util.concurrent.MulticoreWrapper;
import edu.stanford.nlp.util.concurrent.ThreadsafeProcessor;

/**
 * Plot a learning curve from a list of weights generated by OnlineTuner.
 * 
 * @author Spence Green
 *
 */
public class OnlineLearningCurve {

  private static List<List<Sequence<IString>>> loadReferences(String[] filenames, int sourceLength) {
    List<List<Sequence<IString>>> references = new ArrayList<List<Sequence<IString>>>(sourceLength);
    for (String filename : filenames) {
      List<Sequence<IString>> refList = IStrings.fileSplitToIStrings(filename);
      assert refList.size() == sourceLength;
      for (int i = 0; i < sourceLength; ++i) {
        if (references.size() <= i) references.add(new ArrayList<Sequence<IString>>(filenames.length));
        references.get(i).add(refList.get(i));
      }
    }
    assert references.size() == sourceLength;
    return references;
  }

  private static class Decoder implements ThreadsafeProcessor<Pair<Integer,String>,Pair<Integer,Double>> {

    private int id;
    private int childId;
    private Phrasal p;

    public Decoder(Phrasal p, int id) {
      this.id = id;
      childId = id+1;
      this.p = p;
    }

    @Override
    public Pair<Integer, Double> process(Pair<Integer,String> wtsFile) {
      Counter<String> wts = null;
      try {
        wts = IOTools.readWeights(wtsFile.second());
      } catch (IOException e) {
        e.printStackTrace();
      } catch (ClassNotFoundException e) {
        e.printStackTrace();
      }

      p.getScorer(id).updateWeights(wts);
      BLEUMetric<IString, String> bleu = new BLEUMetric<IString, String>(REFS, false);
      BLEUMetric<IString, String>.BLEUIncrementalMetric incMetric = bleu
          .getIncrementalMetric();
      int srcId = 0;
      for (Sequence<IString> sentence : SRC) {
        List<RichTranslation<IString,String>> nbest = p.decode(sentence, srcId++, id);
        incMetric.add(nbest.get(0));
      }
      return new Pair<Integer,Double>(wtsFile.first(), incMetric.score()*100.0);
    }

    @Override
    public ThreadsafeProcessor<Pair<Integer,String>, Pair<Integer, Double>> newInstance() {
      return new Decoder(p, childId++);
    }
  }

  private static List<Sequence<IString>> SRC;
  private static List<List<Sequence<IString>>> REFS;

  /**
   * @param args
   */
  public static void main(String[] args) {
    if (args.length < 5) {
      System.err.printf("Usage: java %s ini_file input_file ref_csv_list wts [wts]%n", 
          OnlineLearningCurve.class.getName());
      System.exit(-1);
    }
    String iniFile = args[0];
    String inputFile = args[1];
    SRC = IStrings.fileSplitToIStrings(inputFile);

    String[] refFiles = args[2].split(",");
    REFS = loadReferences(refFiles, SRC.size());

    List<String> wts = new ArrayList<String>();
    for (int i = 3; i < args.length; ++i) {
      wts.add(args[i]);
    }

    System.err.println("Loading Phrasal...");
    Phrasal p = null;
    try {
      p = Phrasal.loadDecoder(iniFile);
    } catch (IOException e) {
      e.printStackTrace();
      System.exit(-1);
    }
    // Don't lock the feature index.

    MulticoreWrapper<Pair<Integer,String>,Pair<Integer,Double>> wrapper = 
        new MulticoreWrapper<Pair<Integer,String>,Pair<Integer,Double>>(p.getNumThreads(), new Decoder(p, 0));

    Pattern getWtsId = Pattern.compile("\\.(\\d+)\\.binwts");
    for (int i = 0; i < wts.size(); ++i) {
      wrapper.put(new Pair<Integer,String>(i, wts.get(i)));
      while (wrapper.peek()) {
        Pair<Integer,Double> result = wrapper.poll();
        Matcher m = getWtsId.matcher(wts.get(result.first()));
        if (m.find()) {
          String wtsId = m.group(1);
          System.out.printf("%s\t%.2f%n",wtsId,result.second());
        }
      }
    }

    wrapper.join();
    while (wrapper.peek()) {
      Pair<Integer,Double> result = wrapper.poll();
      Matcher m = getWtsId.matcher(wts.get(result.first()));
      if (m.find()) {
        String wtsId = m.group(1);
        System.out.printf("%s\t%.2f%n",wtsId,result.second());
      }
    }
  }
}
